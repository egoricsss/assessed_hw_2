# Домашняя работа №2

**студент**: Сыров Егор Романович

**группа**: 5130901/30005

## Псевдокод алгоритма

```pseudocode
// Алгоритм Косарайю для нахождения ССК графа
// ============================================
// Структуры данных:
// * G = (V, E), V = [0..n-1] — исходный ориентированный граф
// * GT.adj[v] — список u, где (u, v) ∈ E (обратные рёбра исходного графа)
// * numSCC[0..n-1] — массив, где numSCC[v] ∈ [0..k-1] (k — число ССК)

// Функция reverseGraph(G)
// -----------------------
// Спецификация:
// Предусловие: 
//   G — корректный ориентированный граф с вершинами [0..n-1]
// Постусловие:
//   GT — транспонированный граф, где ∀(u, v) ∈ E ⇒ (v, u) ∈ GT.E
// Инвариант:
//   После обработки ребра (u, w) вершина u добавляется в GT.adj[w]
// Описание:
//   Создаёт граф GT, обратный к G. Для каждого ребра (u, w) исходного графа
//   добавляет обратное ребро (w, u) в GT.

функция reverseGraph(G):
    GT ← новый граф с вершинами V = [0..n-1]
    для каждого v ∈ [0..n-1]:
        GT.adj[v] ← []
    для каждого ребра (u, w) ∈ E:
        добавить u в GT.adj[w]  // Транспонирование рёбер
    вернуть GT


// Процедура fillOrder(GT, L)
// --------------------------
// Спецификация:
// Предусловие:
//   GT — транспонированный граф, L — пустой стек
// Постусловие:
//   L содержит вершины в порядке убывания времени завершения обработки в GT
// Инвариант:
//   После обработки вершины v все достижимые из неё вершины уже добавлены в L
// Описание:
//   Выполняет DFS на транспонированном графе GT, заполняя стек L в порядке 
//   завершения обработки вершин (пост-порядке).

процедура fillOrder(GT, L):
    visited[0..n-1] ← [false] * n
    для каждого v ∈ [0..n-1] в порядке 0,1,...,n-1:
        если не visited[v]:
            visit(v, visited, GT, L)


// Процедура visit(v, visited, GT, L)
// -----------------------------------
// Спецификация:
// Предусловие:
//   v ∈ [0..n-1], visited[v] = false
// Постусловие:
//   (1) Все вершины, достижимые из v в GT, помечены как visited
//   (2) v добавлена в стек L после всех достижимых из неё вершин
// Инвариант:
//   Для любого u ∈ GT.adj[v]: если u не обработан до вызова visit(v), 
//   то visit(u) будет вызван до добавления v в стек.

процедура visit(v, visited, GT, L):
    visited[v] ← true
    для каждого u ∈ GT.adj[v]:  // Обход обратного графа
        если не visited[u]:
            visit(u, visited, GT, L)
    L.push(v)  // Фиксация порядка завершения


// Процедура assignComponents(G, L, numSCC)
// ----------------------------------------
// Спецификация:
// Предусловие:
//   L — стек вершин, упорядоченных по времени завершения в GT
// Постусловие:
//   numSCC[v] содержит номер ССК для каждой v ∈ [0..n-1]
// Инвариант:
//   Каждая извлечённая из L вершина v либо:
//   (a) уже обработана (visited[v] = true), либо
//   (b) становится корнем новой ССК
// Описание:
//   Обрабатывает вершины в порядке L, выделяя ССК в исходном графе G.

процедура assignComponents(G, L, numSCC):
    visited[0..n-1] ← [false] * n
    curSCC ← 0
    пока стек L не пуст:
        v ← L.pop()
        если не visited[v]:
            markSCC(v, curSCC, visited, G, numSCC)
            curSCC ← curSCC + 1


// Процедура markSCC(v, curSCC, visited, G, numSCC)
// -------------------------------------------------
// Спецификация:
// Предусловие:
//   v ∈ [0..n-1], visited[v] = false, curSCC ∈ [0..n-1]
// Постусловие:
//   Все вершины, достижимые из v в G, помечены visited и numSCC[v] = curSCC
// Инвариант:
//   Рекурсивно помечает все вершины, достижимые из v в исходном графе G,
//   не пересекаясь с уже обработанными компонентами.
// Описание:
//   Рекурсивный DFS, помечающий вершины текущей ССК.

процедура markSCC(v, curSCC, visited, G, numSCC):
    visited[v] ← true
    numSCC[v] ← curSCC
    для каждого w ∈ G.adj[v]:  // Обход исходного графа
        если не visited[w]:
            markSCC(w, curSCC, visited, G, numSCC)


// Функция findSCC(G)
// -------------------
// Спецификация:
// Предусловие:
//   G — корректный ориентированный граф с вершинами [0..n-1]
// Постусловие:
//   Возвращает массив numSCC, где numSCC[v] — номер ССК вершины v
// Инвариант:
//   Алгоритм Корсарайю выполняется за три этапа:
//   1. Транспонирование графа
//   2. Определение порядка обработки вершин
//   3. Выделение ССК в исходном графе
// Описание:
//   Основная функция алгоритма. Возвращает разметку ССК.

функция findSCC(G):
    GT ← reverseGraph(G)
    L ← пустой стек
    fillOrder(GT, L)
    numSCC[0..n-1] ← [0] * n
    assignComponents(G, L, numSCC)
    вернуть numSCC
```

### Обоснование корректности реализации алгоритма Косарайю

Реализация алгоритма поиска сильно связных компонент (ССК) строго соответствует теоретическому описанию алгоритма Косарайю, приведённому в лекционных материалах. Докажем корректность выполнения каждого этапа алгоритма.

#### **1. Транспонирование графа**
**Теоретический шаг**:  
Для графа $G = (V, E) $ строится обращённый граф  $G^R = (V, E^R)$ , где  $E^R = {(v, u) \mid (u, v) \in E}$ .

**Реализация**:  
Метод `reverse()` создаёт новый граф, в котором для каждого ребра $(u, v) $ исходного графа добавляется обратное ребро $(v, u)$ :

```c++
for (std::size_t u = 0; u < adj.size(); ++u) {
    for (const auto& v : adj[u]) {
        reverse_adj[v].push_back(u); // (v, u) ∈ E^R
    }
}
```
**Корректность**:  
Инвариант ( $E^R = {(v, u) \mid (u, v) \in E} $) сохраняется. Структура сильно связных компонент остаётся неизменной, так как взаимная достижимость вершин в ( $G$ ) эквивалентна их взаимной достижимости в ( $G^R$ ).

---

#### **2. Определение порядка обработки вершин**
**Теоретический шаг**:  
Выполняется обход в глубину (`DFS`) на ($ G^R $), и вершины сохраняются в стек ( $L$ ) в порядке убывания времени завершения их обработки (post-order).

**Реализация**:  
Метод `DFS(std::stack<std::size_t>& order_stack)` обходит ( $G^R$ ) и помещает вершины в стек после завершения их обработки:

```c++
visit(v, visited, [](auto){}, [&order_stack](auto v) { 
    order_stack.push(v); // Post-visit: добавление в стек
});
```
**Корректность**:  
Стек ( $L$ ) заполняется в порядке, обратном топологической сортировке конденсации графа ($ G$ ). Это гарантирует, что при последующем обходе исходного графа первыми обрабатываются "корневые" ССК (компоненты, из которых нет рёбер в необработанные ССК).

---

#### **3. Выделение сильно связных компонент**
**Теоретический шаг**:  
Исходный граф ( $G$ ) обходится в порядке вершин из стека ($ L$). Для каждой непосещённой вершины запускается `DFS`, помечающий все достижимые вершины как принадлежащие одной ССК.

**Реализация**:  
Метод `find_scc()` извлекает вершины из стека ( $L$ ) и вызывает рекурсивный `DFS` для разметки компонент:

```c++
while (!order_stack.empty()) {
    std::size_t v = order_stack.top();
    if (!visited[v]) {
        visit(v, visited, [this](auto v) { 
            this->numSCC[v] = this->curSCC; // Разметка ССК
        }, [](auto) {});
        ++curSCC;
    }
    order_stack.pop();
}
```
**Корректность**:  
- Если вершина ( $v$ ) не была посещена, она является представителем новой ССК. 
- `DFS` помечает все вершины, достижимые из ($v$) в исходном графе ($G$), что соответствует определению сильно связной компоненты. 
- Посещённые вершины исключаются из дальнейшей обработки, что гарантирует попарную непересекаемость ССК.

---

#### **4. Построение метаграфа**
**Теоретический шаг**:  
Метаграф строится как ациклический орграф, вершины которого соответствуют ССК исходного графа. Ребро $(C_i, C_j)$ добавляется, если существует ребро $(u, v) \in E $, где  $u \in C_i $,  $v \in C_j $.

**Реализация**:  
Метод `build_meta_graph()` создаёт список смежности метаграфа на основе номеров ССК:

```c++
for (std::size_t u = 0; u < adj.size(); ++u) {
    int u_comp = numSCC[u];
    for (auto&& v : adj[u]) {
        int v_comp = numSCC[v];
        if (u_comp != v_comp) {
            meta_adj[u_comp].insert(v_comp); // Добавление ребра между ССК
        }
    }
}
```
**Корректность**:  

- Для каждой пары вершин $ (u, v) $, принадлежащих разным ССК, добавляется ребро между соответствующими метавершинами. 
- Метаграф не содержит циклов, так как его топологический порядок соответствует порядку обработки ССК в алгоритме.

## Оценка времени работы 
Алгоритм поиска сильно связных компонент (ССК) имеет **линейную временную сложность** относительно числа вершин и рёбер графа. Для графа $ G = (V, E)$, где ($ |V| $) — число вершин, ($ |E| $) — число рёбер, время работы оценивается следующим образом:

---

#### **1. Транспонирование графа**  
Построение обращённого графа $G^R$:  
- **Время**: $O(|V| + |E|)$.  
- **Операции**: Создание списков смежности для  $G^R $ и инвертирование всех рёбер.

---

#### **2. Обход $ G^R$ в глубину (post-order)**  
Заполнение стека ($L$ порядком завершения обработки вершин):  
- **Время**: ($O(|V| + |E|)$).  
- **Операции**: Стандартный DFS, обрабатывающий каждую вершину и ребро ровно один раз.

---

#### **3. Обход исходного графа $G$ в порядке $L$**  
Выделение ССК через DFS:  
- **Время**: $O(|V| + |E|) $.  
- **Операции**: Один проход по всем вершинам и рёбрам исходного графа.

---

#### **4. Построение метаграфа (опционально)**  
Создание конденсации графа:  
- **Время**: $O(|E|) $.  
- **Операции**: Проверка всех рёбер исходного графа на принадлежность к разным ССК.

---

#### **Итоговая сложность**  
Суммарное время работы алгоритма:  
$T(|V|, |E|) = O(|V| + |E|) + O(|V| + |E|) + O(|V| + |E|) = \Theta(|V| + |E|)$.

